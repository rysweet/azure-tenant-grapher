# Azure Name Sanitizer Service

**Status**: [PLANNED - Implementation Pending]

**Location**: `src/services/azure_name_sanitizer.py`

**Purpose**: Centralized service for sanitizing Azure resource names to meet Azure-specific naming constraints for globally unique resources.

---

## Overview

The Azure Name Sanitizer Service provides a single source of truth for Azure naming rules across all 36 globally unique resource types. It transforms abstracted resource names (generated by `IDAbstractionService`) into Azure-compliant names that meet specific constraints for character sets, length, and format.

### Problem Solved

Azure resources with globally unique DNS names (like Storage Accounts `*.core.windows.net`, Key Vaults `*.vault.azure.net`) have strict naming constraints that vary by resource type. Previously, this logic was duplicated across individual Terraform handlers, with only 5 of 36 handlers implementing it correctly. The sanitizer centralizes this knowledge and ensures consistent, correct name transformation.

### Design Philosophy

- **Single Responsibility**: Knows Azure naming rules, applies them deterministically
- **Stateless**: Pure function - same input always produces same output
- **Reusable**: All 36 globally unique resource types use the same service
- **Testable**: No dependencies on external services or state

---

## Public API

### `AzureNameSanitizer`

Main class providing name sanitization for Azure resources.

```python
from services.azure_name_sanitizer import AzureNameSanitizer

sanitizer = AzureNameSanitizer()

# Sanitize a storage account name
clean_name = sanitizer.sanitize(
    abstracted_name="storage-a1b2c3d4",
    resource_type="Microsoft.Storage/storageAccounts"
)
# Result: "storagea1b2c3d4" (hyphens removed, lowercase)

# Check if a resource type requires global uniqueness
is_global = sanitizer.is_globally_unique("Microsoft.Storage/storageAccounts")
# Result: True

# Get naming constraints for a resource type
constraints = sanitizer.get_constraints("Microsoft.Storage/storageAccounts")
# Result: NamingConstraints(max_length=24, allowed_chars="lowercase_alphanum", ...)
```

---

## Core Methods

### `sanitize(abstracted_name: str, resource_type: str) -> str`

Sanitizes a resource name according to Azure naming rules for the specified resource type.

**Parameters**:
- `abstracted_name` (str): The abstracted name from `IDAbstractionService` (e.g., `"storage-a1b2c3d4"`)
- `resource_type` (str): Azure resource type (e.g., `"Microsoft.Storage/storageAccounts"`)

**Returns**:
- `str`: Azure-compliant resource name

**Raises**:
- `ValueError`: If resource type is unknown
- `ValueError`: If name cannot be sanitized to meet constraints

**Example**:
```python
sanitizer = AzureNameSanitizer()

# Storage Account - removes hyphens, lowercase only
result = sanitizer.sanitize("storage-a1b2c3d4", "Microsoft.Storage/storageAccounts")
# Output: "storagea1b2c3d4"

# Container Registry - removes hyphens, alphanumeric only
result = sanitizer.sanitize("acr-x9y8z7", "Microsoft.ContainerRegistry/registries")
# Output: "acrx9y8z7"

# Key Vault - keeps hyphens, validates format
result = sanitizer.sanitize("keyvault-a1b2c3", "Microsoft.KeyVault/vaults")
# Output: "keyvault-a1b2c3"

# SQL Server - keeps hyphens, lowercase
result = sanitizer.sanitize("sql-server-01", "Microsoft.Sql/servers")
# Output: "sql-server-01"
```

---

### `is_globally_unique(resource_type: str) -> bool`

Checks if a resource type requires a globally unique name across all of Azure.

**Parameters**:
- `resource_type` (str): Azure resource type

**Returns**:
- `bool`: True if resource requires global uniqueness

**Example**:
```python
sanitizer = AzureNameSanitizer()

sanitizer.is_globally_unique("Microsoft.Storage/storageAccounts")  # True
sanitizer.is_globally_unique("Microsoft.KeyVault/vaults")  # True
sanitizer.is_globally_unique("Microsoft.Compute/virtualMachines")  # False
```

---

### `get_constraints(resource_type: str) -> NamingConstraints`

Returns the naming constraints for a specific resource type.

**Parameters**:
- `resource_type` (str): Azure resource type

**Returns**:
- `NamingConstraints`: Object containing max_length, allowed_chars, pattern, etc.

**Example**:
```python
constraints = sanitizer.get_constraints("Microsoft.Storage/storageAccounts")

print(constraints.max_length)        # 24
print(constraints.allowed_chars)     # "lowercase_alphanum"
print(constraints.dns_pattern)       # "*.core.windows.net"
print(constraints.must_start_with)   # "letter_or_number"
```

---

## Supported Resource Types

The sanitizer supports **36 globally unique Azure resource types** across 6 categories:

### CRITICAL Priority (10 types)

| Resource Type | Max Length | Character Rules | DNS Pattern |
|--------------|------------|-----------------|-------------|
| `Microsoft.Storage/storageAccounts` | 24 | Lowercase alphanum ONLY | `*.core.windows.net` |
| `Microsoft.KeyVault/vaults` | 24 | Alphanum + hyphens, start with letter | `*.vault.azure.net` |
| `Microsoft.Web/sites` | 60 | Alphanum + hyphens | `*.azurewebsites.net` |
| `Microsoft.Sql/servers` | 63 | Lowercase, alphanum + hyphens | `*.database.windows.net` |
| `Microsoft.ContainerRegistry/registries` | 50 | Alphanum ONLY (no hyphens) | `*.azurecr.io` |
| `Microsoft.DBforPostgreSQL/servers` | 63 | Lowercase, alphanum + hyphens | `*.postgres.database.azure.com` |
| `Microsoft.DBforMySQL/servers` | 63 | Lowercase, alphanum + hyphens | `*.mysql.database.azure.com` |
| `Microsoft.ApiManagement/service` | 50 | Alphanum + hyphens | `*.azure-api.net` |
| `Microsoft.Cdn/profiles` | 260 | Alphanum + hyphens | `*.azureedge.net` |
| `Microsoft.AppConfiguration/configurationStores` | 50 | Alphanum + hyphens | `*.azconfig.io` |

### Integration/Messaging (4 types)
- Service Bus Namespaces: `*.servicebus.windows.net` (50 chars)
- Event Hub Namespaces: `*.servicebus.windows.net` (50 chars)
- Event Grid Domains: `*.{region}.eventgrid.azure.net` (50 chars)
- SignalR Service: `*.service.signalr.net` (63 chars)

### API/Networking (5 types)
- Front Door: `*.azurefd.net` (64 chars)
- Traffic Manager: `*.trafficmanager.net` (63 chars)
- Application Gateway: Regional unique (80 chars)
- Azure Firewall: Regional unique (80 chars)
- Bastion Host: Regional unique (80 chars)

### Data/Analytics (8 types)
- Data Factory: `*.datafactory.azure.net` (63 chars)
- Synapse Workspace: `*.azuresynapse.net` (50 chars)
- Databricks Workspace: `*.azuredatabricks.net` (30 chars)
- HDInsight Cluster: `*.azurehdinsight.net` (59 chars)
- Cosmos DB: `*.documents.azure.com` (44 chars)
- Redis Cache: `*.redis.cache.windows.net` (63 chars)
- Search Service: `*.search.windows.net` (60 chars)
- Analysis Services: `*.asazure.windows.net` (63 chars)

### AI/ML/IoT (4 types)
- Cognitive Services: `*.cognitiveservices.azure.com` (64 chars)
- Machine Learning Workspace: `*.api.azureml.ms` (33 chars)
- IoT Hub: `*.azure-devices.net` (50 chars)
- IoT Central: `*.azureiotcentral.com` (63 chars)

### Specialized (5 types)
- Bot Service: `*.azurewebsites.net` (64 chars)
- Communication Services: `*.communication.azure.com` (63 chars)
- Spring Cloud Service: `*.azuremicroservices.io` (32 chars)
- Managed Grafana: `*.grafana.azure.com` (23 chars)
- Static Web Apps: `*.azurestaticapps.net` (40 chars)

---

## Before/After Examples

### Storage Account

```python
# BEFORE sanitization (from IDAbstractionService)
abstracted_name = "storage-a1b2c3d4e5f6g7h8"

# AFTER sanitization
sanitized_name = sanitizer.sanitize(
    abstracted_name,
    "Microsoft.Storage/storageAccounts"
)
# Result: "storagea1b2c3d4e5f6"
# Changes: Hyphens removed, lowercase, truncated to 18 chars (leave room for 6-char suffix)
```

### Container Registry

```python
# BEFORE
abstracted_name = "acr-x9y8z7w6v5u4"

# AFTER
sanitized_name = sanitizer.sanitize(
    abstracted_name,
    "Microsoft.ContainerRegistry/registries"
)
# Result: "acrx9y8z7w6v5u4"
# Changes: Hyphens removed, alphanumeric only
```

### Key Vault

```python
# BEFORE
abstracted_name = "vault-prod-east"

# AFTER
sanitized_name = sanitizer.sanitize(
    abstracted_name,
    "Microsoft.KeyVault/vaults"
)
# Result: "vault-prod-east"
# Changes: Hyphens preserved (allowed), validated format
```

### PostgreSQL Server

```python
# BEFORE
abstracted_name = "postgres-a1b2c3d4"

# AFTER
sanitized_name = sanitizer.sanitize(
    abstracted_name,
    "Microsoft.DBforPostgreSQL/servers"
)
# Result: "postgres-a1b2c3d4"
# Changes: Hyphens preserved, lowercase enforced
```

---

## Usage in Terraform Handlers

Handlers use the sanitizer to transform abstracted names before generating Terraform configurations.

### Example: Storage Account Handler

```python
from services.azure_name_sanitizer import AzureNameSanitizer

class StorageAccountHandler(ResourceHandler):
    def emit(self, resource: Dict[str, Any], context: EmitterContext):
        # Get abstracted name from graph
        abstracted_name = resource.get("name", "unknown")

        # Sanitize for Azure constraints
        sanitizer = AzureNameSanitizer()
        sanitized_name = sanitizer.sanitize(
            abstracted_name,
            "Microsoft.Storage/storageAccounts"
        )

        # Add tenant suffix for cross-tenant uniqueness
        if context.target_tenant_id and context.source_tenant_id != context.target_tenant_id:
            tenant_suffix = context.target_tenant_id[-6:].replace("-", "").lower()
            sanitized_name = f"{sanitized_name}{tenant_suffix}"

        config = {
            "name": sanitized_name,
            "resource_group_name": resource.get("resource_group_name"),
            # ... other config
        }

        return ("azurerm_storage_account", self.sanitize_name(abstracted_name), config)
```

### Example: Key Vault Handler

```python
class VaultHandler(ResourceHandler):
    def emit(self, resource: Dict[str, Any], context: EmitterContext):
        abstracted_name = resource.get("name", "unknown")

        sanitizer = AzureNameSanitizer()
        sanitized_name = sanitizer.sanitize(
            abstracted_name,
            "Microsoft.KeyVault/vaults"
        )

        # Key Vaults allow hyphens, so add suffix with hyphen
        if context.target_tenant_id and context.source_tenant_id != context.target_tenant_id:
            tenant_suffix = context.target_tenant_id[-6:].replace("-", "").lower()
            sanitized_name = f"{sanitized_name}-{tenant_suffix}"

        config = {
            "name": sanitized_name,
            "location": resource.get("location"),
            "sku_name": "standard",
            # ... other config
        }

        return ("azurerm_key_vault", self.sanitize_name(abstracted_name), config)
```

---

## Design Details

### Architecture Position

The sanitizer sits between the ID Abstraction Service and Terraform handlers:

```
┌──────────────────────────────────────────────────────────┐
│ 1. Discovery Phase                                        │
│    Azure API → Original resource names → Neo4j graph      │
└──────────────────────┬───────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────────────┐
│ 2. Abstraction Phase                                      │
│    IDAbstractionService → Generic abstracted names        │
│    Example: "storage-a1b2c3d4" (with hyphen)              │
└──────────────────────┬───────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────────────┐
│ 3. Azure Name Sanitization Phase (NEW)                   │
│    AzureNameSanitizer → Apply resource-specific rules     │
│    - Storage: Remove hyphens → "storagea1b2c3d4"          │
│    - ACR: Remove hyphens → "acra1b2c3d4"                  │
│    - Others: Validate format, length                      │
└──────────────────────┬───────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────────────┐
│ 4. Global Uniqueness Phase                                │
│    Add tenant suffix for cross-tenant deployments         │
│    - Conditional: Only if target_tenant != source_tenant  │
│    - Format: {sanitized_name}{tenant_suffix}              │
│    Example: "storagea1b2c3d4abc123" (24 chars total)      │
└──────────────────────┬───────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────────────┐
│ 5. IaC Generation Phase                                   │
│    TerraformEmitter → Generate .tf files with valid names │
└──────────────────────────────────────────────────────────┘
```

### Naming Constraint Rules

The sanitizer encodes Azure naming rules for each resource type:

1. **Character Set Rules**:
   - `lowercase_alphanum`: Only lowercase letters and numbers (Storage, PostgreSQL)
   - `alphanum_only`: Letters and numbers, case-insensitive (Container Registry)
   - `alphanum_hyphen`: Letters, numbers, and hyphens (Key Vault, SQL Server)

2. **Length Constraints**:
   - Enforces maximum length per resource type
   - Reserves space for tenant suffixes when needed
   - Truncates intelligently while preserving uniqueness

3. **Format Rules**:
   - Must start with letter or number (not hyphen)
   - Cannot end with hyphen
   - No consecutive hyphens
   - Case normalization (lowercase for most types)

4. **DNS Pattern Awareness**:
   - Knows which resources create public DNS entries
   - Validates names will work with Azure DNS constraints

---

## Testing Strategy

### Unit Tests (60%)

Test each resource type's sanitization rules:

```python
def test_storage_account_hyphen_removal():
    sanitizer = AzureNameSanitizer()
    result = sanitizer.sanitize("storage-a1b2c3", "Microsoft.Storage/storageAccounts")
    assert result == "storagea1b2c3"
    assert "-" not in result

def test_storage_account_max_length():
    sanitizer = AzureNameSanitizer()
    long_name = "storage-" + "a" * 50
    result = sanitizer.sanitize(long_name, "Microsoft.Storage/storageAccounts")
    assert len(result) <= 24

def test_key_vault_preserves_hyphens():
    sanitizer = AzureNameSanitizer()
    result = sanitizer.sanitize("vault-prod-east", "Microsoft.KeyVault/vaults")
    assert "-" in result
    assert result == "vault-prod-east"
```

### Integration Tests (30%)

Test sanitizer integration with handlers:

```python
def test_storage_handler_uses_sanitizer():
    handler = StorageAccountHandler()
    context = EmitterContext(...)
    resource = {"name": "storage-test-name", ...}

    _, _, config = handler.emit(resource, context)

    # Name should be sanitized (no hyphens)
    assert "-" not in config["name"]
```

### Edge Cases

```python
def test_empty_name():
    sanitizer = AzureNameSanitizer()
    with pytest.raises(ValueError, match="Name cannot be empty"):
        sanitizer.sanitize("", "Microsoft.Storage/storageAccounts")

def test_unknown_resource_type():
    sanitizer = AzureNameSanitizer()
    with pytest.raises(ValueError, match="Unknown resource type"):
        sanitizer.sanitize("test", "Microsoft.Unknown/resource")

def test_consecutive_hyphens_removed():
    sanitizer = AzureNameSanitizer()
    result = sanitizer.sanitize("vault--prod", "Microsoft.KeyVault/vaults")
    assert "--" not in result
```

---

## Migration Considerations

### Handler Updates Required

5 existing handlers need to be updated to use the sanitizer:

1. `storage_account.py` - Remove manual hyphen stripping (line 85)
2. `container_registry.py` - Remove manual hyphen stripping (line 49)
3. `sql_server.py` - Replace manual sanitization with sanitizer call
4. `vault.py` - Replace MD5 hash logic with sanitizer
5. `app_service.py` - Replace manual sanitization with sanitizer call

### Backward Compatibility

- Sanitizer produces same output as existing manual sanitization
- No breaking changes to abstracted graph format
- Existing Terraform configurations remain valid

### Rollout Strategy

1. **Phase 1**: Implement `AzureNameSanitizer` service
2. **Phase 2**: Update 5 existing handlers to use sanitizer
3. **Phase 3**: Add sanitizer calls to 31 remaining handlers
4. **Phase 4**: Validate all handlers produce Azure-compliant names

---

## References

- **Investigation Report**: `.claude/docs/INVESTIGATION_globally_unique_names_20260113.md`
- **Azure Naming Rules**: [Microsoft Learn - Naming rules and restrictions for Azure resources](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules)
- **Research Document**: Commit `3a66f1d` - `AZURE_GLOBALLY_UNIQUE_NAMES_RESEARCH.md`
- **Related Issues**: Bug #28 (within-tenant collisions), Bug #52-53 (cross-tenant collisions), Bug #12-18 (resource-specific fixes)

---

## Module Philosophy

**Single Responsibility**: Knows Azure naming rules, nothing else

**Stateless**: Pure functions with no side effects

**Reusable**: Single implementation for 36 resource types

**Testable**: No external dependencies or mutable state

**Deterministic**: Same input → same output, always

---

*This is a [PLANNED] feature following Document-Driven Development. Implementation will match this specification exactly.*
