---
name: learning-path-builder
description: |
  Creates personalized learning paths for technologies, frameworks, or concepts.
  Use for user-interactive session only for onboarding new technologies, hackathon skill-building, or personal development planning. Not for use in automated development or investigation.
  Sequences resources (docs, tutorials, exercises) based on current skill level and learning goals.
  Adapts to learning style: hands-on, theory-first, project-based.
---

# Learning Path Builder Skill

## Purpose

This skill creates personalized, structured learning paths that guide users through mastering new technologies, frameworks, or concepts. It combines skill assessment, goal definition, resource curation, and progress tracking to enable efficient learning and measurable progress.

## When to Use This Skill

- **New Technology Adoption**: Learning a new framework, language, or tool
- **Onboarding**: Bringing team members up to speed on project technologies
- **Hackathon Preparation**: Building required skills before a competition
- **Career Development**: Structured path for advancing in a particular domain
- **Knowledge Gaps**: Filling specific skill gaps in your technical stack
- **Upskilling**: Transitioning from one technology to another
- **Learning Optimization**: Creating efficient paths tailored to your learning style

## Core Philosophy: Personalized Progressive Learning

**Assessment** → **Goal Setting** → **Path Sequencing** → **Resource Curation** → **Progress Tracking** → **Adaptation**

A good learning path:

- Matches current skill level (beginner, intermediate, advanced)
- Aligns with learning goals and timeline
- Sequences concepts from simple to complex
- Mixes multiple resource types (docs, tutorials, exercises, projects)
- Provides checkpoints and milestones
- Adapts to learning style and feedback

## Learning Path Components

Every personalized learning path includes:

### 1. Skills Assessment

- Current skill level (beginner/intermediate/advanced)
- Relevant prior knowledge
- Learning experience preference
- Time availability
- Career/project goals

### 2. Goal Definition

- Primary learning objective
- Target proficiency level
- Timeline and milestones
- Success metrics
- Constraints and dependencies

### 3. Concept Sequence

- Prerequisite concepts
- Progressive complexity levels
- Learning foundations first
- Builds practical understanding over time

### 4. Resource Curation

- Official documentation
- High-quality tutorials
- Interactive exercises
- Real-world projects
- Community resources

### 5. Learning Checkpoints

- Milestone assessments
- Practical exercises
- Mini-projects
- Reflection points
- Progress validation

### 6. Progress Tracking

- Completed modules
- Assessed skill gains
- Time investment
- Confidence levels
- Feedback integration

## Step-by-Step Assessment Process

### Step 1: Assess Current Skill Level

Ask targeted questions to understand:

1. **Technical Background**
   - Languages/frameworks you already know
   - Similar technologies you've used
   - Years of programming experience
   - Relevant professional experience

2. **Learning Style Preference**
   - Hands-on (learn by doing)
   - Theory-first (understand concepts)
   - Project-based (learn via real problems)
   - Visual (diagrams, videos)
   - Reading (documentation, blogs)

3. **Time Availability**
   - Hours per week available
   - Preferred learning schedule
   - Commitment timeline
   - Flexibility (can vary per week)

4. **Current Knowledge Gaps**
   - What specifically needs to be learned
   - Existing knowledge in adjacent areas
   - Misconceptions to address
   - Prior learning attempts

### Step 2: Define Clear Learning Goals

Establish SMART goals:

1. **Specific**: What exactly will you be able to do?
2. **Measurable**: How will you know you've succeeded?
3. **Achievable**: Is this realistic given your timeline?
4. **Relevant**: How does this align with career/project needs?
5. **Time-bound**: When do you want to achieve this?

### Step 3: Sequence Concepts Progressively

Create learning sequence from foundations to advanced:

1. **Foundation Concepts** (Week 1-2)
   - Core terminology
   - Basic architecture
   - Key principles
   - Simple examples

2. **Core Functionality** (Week 2-4)
   - Main features
   - Common patterns
   - Practical exercises
   - Real examples

3. **Advanced Topics** (Week 4+)
   - Complex scenarios
   - Performance optimization
   - Best practices
   - Production deployment

4. **Specialization** (As needed)
   - Domain-specific knowledge
   - Integration patterns
   - Advanced debugging
   - Expert techniques

### Step 4: Curate High-Quality Resources

For each concept, provide:

1. **Official Documentation**
   - Links to relevant docs
   - Specific sections to focus on
   - Time estimates
   - Difficulty level

2. **Tutorials and Guides**
   - Author/source credibility
   - Format (text, video, interactive)
   - Hands-on vs theoretical
   - Time to complete

3. **Interactive Exercises**
   - Practice problems
   - Coding exercises
   - Interactive sandboxes
   - Difficulty progression

4. **Real-World Projects**
   - Beginner projects (1-2 days)
   - Intermediate projects (1-2 weeks)
   - Advanced projects (2+ weeks)
   - Open-source contributions

5. **Community Resources**
   - Forums and Q&A sites
   - Blogs and articles
   - Videos and screencasts
   - Podcasts and talks

### Step 5: Define Checkpoints and Milestones

Establish clear progress markers:

1. **Knowledge Checkpoints**
   - Quiz or self-assessment
   - Concept understanding verification
   - Time to complete

2. **Practical Exercises**
   - Hands-on coding tasks
   - Expected time
   - Success criteria
   - Difficulty level

3. **Mini-Projects**
   - Build something meaningful
   - Combine multiple concepts
   - Realistic scenario
   - Review guidelines

4. **Milestone Assessments**
   - Comprehensive projects
   - Demonstrate proficiency
   - Clear success criteria
   - Feedback mechanism

### Step 6: Plan Progress Tracking

Setup mechanism for tracking:

1. **Weekly Check-ins**
   - Resources completed
   - Concepts mastered
   - Challenges encountered
   - Time spent

2. **Skill Validation**
   - Self-assessment
   - Quiz scores
   - Project quality
   - Peer review

3. **Timeline Adjustment**
   - Accelerate if on track
   - Extend if needed
   - Adapt based on feedback
   - Celebrate milestones

## Learning Path Template

```markdown
# [Technology] Learning Path

## Assessment

### Your Profile

- **Current Skill Level**: [Beginner/Intermediate/Advanced]
- **Learning Style**: [Hands-on/Theory/Project-based/Mix]
- **Time Available**: [X hours/week]
- **Prior Experience**: [Relevant technologies]

### Goals

- **Primary Objective**: [What you'll be able to do]
- **Target Level**: [Beginner/Intermediate/Advanced proficiency]
- **Timeline**: [X weeks]
- **Success Criteria**: [Measurable outcomes]

## Concept Sequence

### Foundation (Week 1)

**Concepts**: Core terminology, basic architecture, key principles

**Resources**:

1. [Resource Title](link) - X hour read/watch
2. [Interactive Exercise](link) - X hours hands-on
3. **Checkpoint**: Take quiz or build minimal example

### Core Functionality (Week 2-3)

**Concepts**: Main features, common patterns, real-world usage

**Resources**:

1. [Tutorial](link) - X hours
2. [Project](link) - Build working application
3. **Checkpoint**: Code review or project demo

### Advanced Topics (Week 4+)

**Concepts**: Complex scenarios, optimization, production patterns

**Resources**:

1. [Advanced Guide](link) - X hours
2. [Real Project](link) - Tackle open-source or real problem
3. **Checkpoint**: Implement advanced feature or optimization

## Progress Tracking

| Week | Topic          | Resource           | Status      | Time | Notes                |
| ---- | -------------- | ------------------ | ----------- | ---- | -------------------- |
| 1    | Foundations    | Docs + Tutorial    | In Progress | 5h   | Good grasp of basics |
| 2    | Core Feature A | Exercise + Project | Pending     | 0h   | Not started          |

## Next Steps

- Start Week 1 resources
- Join community (Discord/Forums)
- Set up development environment
```

## Learning Path Examples

### Example 1: React Learning Path (Beginner to Intermediate)

```
# React Learning Path - 4 Weeks

## Assessment
- **Current Level**: Intermediate JavaScript
- **Learning Style**: Hands-on with theory background
- **Time**: 10 hours/week
- **Goal**: Build production-ready React applications

## Week 1: Foundations
1. React Docs - Main Concepts (2 hours)
2. JSX fundamentals (1 hour)
3. Interactive sandbox exercises (2 hours)
4. Checkpoint: Build static component library

## Week 2: Component Lifecycle & Hooks
1. React Docs - Hooks (2 hours)
2. State management patterns (1.5 hours)
3. Build Todo app with hooks (3 hours)
4. Checkpoint: Explain useEffect cleanup

## Week 3: Advanced Patterns
1. Context API tutorial (1.5 hours)
2. Performance optimization (2 hours)
3. Build multi-page app (4 hours)
4. Checkpoint: Code performance review

## Week 4: Integration & Real Project
1. API integration patterns (1.5 hours)
2. Testing React components (1.5 hours)
3. Build real project (5 hours)
4. Checkpoint: Deploy live project

## Resources
- React.dev official docs
- React Query for data fetching
- Vitest for testing
- Project: Weather app with real API
```

### Example 2: Docker Learning Path (Beginner)

```
# Docker Learning Path - 3 Weeks

## Assessment
- **Current Level**: Basic Linux command line
- **Learning Style**: Project-based
- **Time**: 8 hours/week
- **Goal**: Containerize applications, run multi-container services

## Week 1: Docker Basics
1. Docker Docs - Getting Started (1 hour)
2. Install Docker locally (0.5 hours)
3. Run and interact with containers (2 hours)
4. Dockerfile fundamentals (1 hour)
5. Checkpoint: Build Node.js app Dockerfile

## Week 2: Images and Registries
1. Docker Images deep dive (1.5 hours)
2. Docker Hub tutorial (1 hour)
3. Build and push custom image (2 hours)
4. Multi-stage builds (1 hour)
5. Checkpoint: Optimize image size

## Week 3: Docker Compose & Real App
1. Docker Compose basics (1.5 hours)
2. Multi-container application (2 hours)
3. Networking and volumes (1 hour)
4. Containerize your own project (3 hours)
5. Checkpoint: Deploy compose stack

## Resources
- Docker official documentation
- Play with Docker online sandbox
- Project: Containerize existing app
```

### Example 3: TypeScript Learning Path (Intermediate Developer)

```
# TypeScript Learning Path - 6 Weeks

## Assessment
- **Current Level**: Intermediate JavaScript, familiar with types
- **Learning Style**: Theory-first with practical coding
- **Time**: 5-7 hours/week
- **Goal**: Write production TypeScript, advanced patterns

## Week 1-2: Fundamentals
- Type system basics
- Generics introduction
- Common types and patterns
- Project: Refactor JS module to TS

## Week 3-4: Advanced Features
- Advanced generics
- Conditional types
- Utility types
- Project: Build reusable utilities

## Week 5-6: Ecosystem & Real Code
- TypeScript with frameworks
- Testing typed code
- Production patterns
- Project: Full-stack TypeScript app

## Resources
- TypeScript Handbook
- Advanced Types deep dives
- Real project in your stack
```

## Usage Examples

### Example 1: Create a Learning Path from Scratch

```
User: I want to learn Vue.js and I have 10 hours per week.
      I know React and prefer hands-on learning.

Claude:

1. **Assessment** (clarify your situation):
   - You know React, so component model is familiar
   - Want hands-on learning
   - 10 hours/week available
   - Timeline: 4-6 weeks for intermediate proficiency

2. **Create Personalized Path**:
   - Week 1: Vue fundamentals (leverage React knowledge)
   - Week 2: Composition API (vs Options - choose best path)
   - Week 3-4: Real project
   - Week 5-6: Advanced patterns

3. **Provide Resources**:
   - Official Vue.dev documentation
   - Interactive tutorials
   - Comparison guide: Vue vs React
   - Project suggestions

4. **Setup Tracking**:
   - Weekly checkins
   - Progress dashboard
   - Milestone assessments
```

### Example 2: Adapt Path Based on Feedback

```
User: I finished Week 2 of the React path but it was harder than expected.

Claude:

1. **Understand Challenge**:
   - Ask what was difficult
   - Assess understanding level
   - Identify knowledge gaps

2. **Adapt Path**:
   - Slow pace if needed
   - Add prerequisite concepts
   - Suggest alternative resources
   - Adjust timeline

3. **Provide Support**:
   - Recommend easier tutorial
   - Break down complex concept
   - Provide additional exercises
   - Schedule extra checkpoint

4. **Update Tracking**:
   - Adjust timeline
   - Add buffer weeks
   - Note learnings for future
```

### Example 3: Multi-Technology Learning Path

```
User: I need to learn Kubernetes, Docker, and cloud deployment
      for an upcoming project. What's the right order?

Claude:

1. **Assess Prerequisites**:
   - Kubernetes requires Docker foundation
   - Both need Linux/container basics
   - Suggest learning order

2. **Create Integrated Path**:
   - Foundation: Linux & container concepts
   - Phase 1: Docker (3 weeks)
   - Phase 2: Kubernetes (4 weeks)
   - Phase 3: Cloud deployment (2 weeks)

3. **Show Dependencies**:
   - Docker exercises inform Kubernetes concepts
   - Real project ties everything together

4. **Total Commitment**:
   - X weeks at Y hours/week
   - Milestone dates
   - Integration points
```

## Assessment Checklist

### Path Quality Verification

- [ ] Matches stated skill level
- [ ] Aligns with learning goals
- [ ] Realistic timeline given available hours
- [ ] Concepts sequenced from simple to complex
- [ ] Mix of theory and hands-on practice
- [ ] Multiple resource types included
- [ ] Clear checkpoints defined
- [ ] Success criteria measurable
- [ ] Includes real-world projects
- [ ] Accounts for learning style preference

### Resource Quality

- [ ] From authoritative sources
- [ ] Recently updated (within 6 months)
- [ ] Accurate and complete
- [ ] Well-reviewed by community
- [ ] Free or reasonable cost
- [ ] Accessible (language, format)
- [ ] Estimated time provided
- [ ] Difficulty level labeled

### Progress Tracking

- [ ] Clear way to track completion
- [ ] Checkpoint assessments defined
- [ ] Adjustment mechanism for struggles
- [ ] Celebration of milestones
- [ ] Community/support resources listed
- [ ] Reflection mechanism built in

## Key Principles

### 1. Personalization Over Generic

- Paths adapt to individual learning style
- Respect prior knowledge and background
- Adjust pace based on feedback
- Consider time constraints

### 2. Progressive Complexity

- Foundation before advanced
- Simple examples before real code
- Theory before deep dives
- Repeating concepts in new contexts

### 3. Multiple Resource Types

- Don't rely on single format
- Mix reading, video, hands-on, projects
- Vary authors and perspectives
- Include community knowledge

### 4. Measurable Progress

- Clear checkpoints and milestones
- Self-assessment mechanisms
- Projects demonstrate learning
- Tracked time investment

### 5. Flexibility and Adaptation

- Adjust when struggling
- Accelerate when ahead
- Skip prerequisites if known
- Pivot based on interests

## Common Pitfalls to Avoid

- **Unrealistic Timelines**: Don't compress learning into impossible timeframes
- **Too Many Resources**: Curate quality over quantity
- **Skipping Fundamentals**: Never skip prerequisites
- **No Hands-On**: Theory alone doesn't build skills
- **Missing Checkpoints**: Progress visibility matters
- **Ignoring Learning Style**: Same path doesn't work for everyone
- **No Real Projects**: Theory must connect to practice
- **Overwhelming Scope**: Break into manageable pieces

## Success Criteria

A successful learning path:

- [ ] User completes all checkpoints
- [ ] Skills are applied in real projects
- [ ] User reports confidence improvement
- [ ] Can teach others the concepts
- [ ] Applies learning in work/personal projects
- [ ] Continues learning independently
- [ ] Understands when to seek advanced resources

## Integration with Other Skills

- **Project Builder**: Use created learning paths for onboarding new team members
- **Module Spec Generator**: Document what was learned in structured format
- **Performance Optimizer**: Identify which resources were most efficient

## Advanced Features

### Learning Style Adaptation

- Adjust resources based on learning preference
- Mix theory-first for analytical learners
- Project-first for hands-on learners
- Visual resources for visual thinkers

### Prerequisite Chaining

- Identify dependencies between topics
- Skip if already known
- Add depth if weak areas identified
- Create customized starting point

### Community Integration

- Link to local meetups
- Suggest Discord communities
- Open-source projects to contribute to
- Mentorship opportunities

### Career Path Integration

- Connect learning to career goals
- Show progression to next level
- Identify specialization options
- Build portfolio through projects
