"""Undeploy command for safely destroying IaC deployments.

This module provides the CLI command for destroying deployed
Azure resources managed by Terraform.
"""

import asyncio
import logging
import sys
from pathlib import Path
from typing import Any, Dict, Optional

import click

from ..config_manager import get_config_for_tenant
from ..deployment_registry import DeploymentRegistry
from ..terraform_destroyer import TerraformDestroyer, UndeploymentConfirmation

logger = logging.getLogger(__name__)


def _parse_remaining_resources(stderr: str, stdout: str) -> Optional[Dict[str, Any]]:
    """Parse Terraform destroy output to identify resources that failed to be destroyed.

    Args:
        stderr: Terraform stderr output
        stdout: Terraform stdout output

    Returns:
        Dictionary with remaining resource information or None if parsing fails

    Example output:
        {
            "count": 3,
            "resources": ["azurerm_resource_group.main", "azurerm_virtual_network.vnet"],
            "error_summary": "Dependency conflict - resources have dependencies that prevent deletion"
        }
    """
    try:
        import re

        remaining = {"count": 0, "resources": [], "error_summary": ""}

        # Combine stdout and stderr for parsing
        combined_output = f"{stdout}\n{stderr}"

        # Pattern 1: Extract resource addresses from error messages
        # Terraform typically reports: "Error: deleting Resource (resource_id): ..."
        resource_pattern = re.compile(r"Error:.*?deleting\s+(\w+)\s+\(([^)]+)\)", re.IGNORECASE)
        matches = resource_pattern.findall(combined_output)

        for resource_type, resource_id in matches:
            resource_addr = f"{resource_type}({resource_id})"
            if resource_addr not in remaining["resources"]:
                remaining["resources"].append(resource_addr)

        # Pattern 2: Extract from "still exists" messages
        exists_pattern = re.compile(r"([a-z_]+\.[a-z_0-9]+).*still exists", re.IGNORECASE)
        exists_matches = exists_pattern.findall(combined_output)

        for resource_addr in exists_matches:
            if resource_addr not in remaining["resources"]:
                remaining["resources"].append(resource_addr)

        # Pattern 3: Count from summary line (e.g., "3 resources failed to destroy")
        summary_pattern = re.compile(r"(\d+)\s+resource[s]?\s+failed", re.IGNORECASE)
        summary_match = summary_pattern.search(combined_output)

        if summary_match:
            remaining["count"] = int(summary_match.group(1))
        else:
            remaining["count"] = len(remaining["resources"])

        # Extract error summary (first error line)
        error_lines = [line for line in combined_output.split("\n") if "Error:" in line]
        if error_lines:
            remaining["error_summary"] = error_lines[0][:200]  # First error, truncated

        # If we found at least one resource or count, return the dict
        if remaining["count"] > 0 or remaining["resources"]:
            return remaining

        # No specific resources identified, return minimal info
        return {
            "count": 0,
            "resources": [],
            "error_summary": "Destroy failed - check Terraform output for details"
        }

    except Exception as e:
        logger.warning(f"Failed to parse remaining resources: {e}")
        return None


@click.command()
@click.option("--deployment-id", help="ID of deployment to destroy")
@click.option("--directory", help="IaC output directory to destroy")
@click.option(
    "--tenant",
    type=click.Choice(["1", "2"]),
    required=True,
    help="Target tenant for destruction",
)
@click.option(
    "--force", is_flag=True, help="Skip interactive confirmation (dangerous!)"
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="Show what would be destroyed without actually destroying",
)
@click.option("--no-backup", is_flag=True, help="Skip state backup before destruction")
def undeploy(
    deployment_id: Optional[str],
    directory: Optional[str],
    tenant: str,
    force: bool,
    dry_run: bool,
    no_backup: bool,
) -> None:
    """Safely destroy deployed Azure resources.

    This command destroys Azure resources that were deployed using
    Infrastructure-as-Code generated by the Azure Tenant Grapher.

    You must specify either --deployment-id or --directory to identify
    the deployment to destroy.

    Examples:
        atg undeploy --deployment-id deploy-20240120-143022 --tenant 2
        atg undeploy --directory outputs/iac-out-20240120-143022 --tenant 2 --dry-run
    """
    # Validate arguments
    if not deployment_id and not directory:
        click.echo(
            "‚ùå Error: Must specify either --deployment-id or --directory", err=True
        )
        sys.exit(1)

    if deployment_id and directory:
        click.echo(
            "‚ùå Error: Cannot specify both --deployment-id and --directory", err=True
        )
        sys.exit(1)

    # Initialize registry
    registry = DeploymentRegistry()

    # Find deployment
    if deployment_id:
        deployment = registry.get_deployment(deployment_id)
        if not deployment:
            click.echo(f"‚ùå Error: Deployment '{deployment_id}' not found", err=True)
            sys.exit(1)
        working_dir = Path(deployment["directory"])
    else:
        if directory is None:
            click.echo("‚ùå Error: Directory must be specified", err=True)
            sys.exit(1)
        working_dir = Path(directory)
        if not working_dir.exists():
            click.echo(f"‚ùå Error: Directory '{directory}' does not exist", err=True)
            sys.exit(1)

        # Try to find deployment by directory
        deployment = (
            registry.get_deployment_by_directory(directory) if directory else None
        )
        if not deployment:
            # Create a temporary deployment record for untracked deployments
            click.echo(
                "‚ö†Ô∏è  Warning: This directory is not tracked in the deployment registry"
            )
            deployment = {
                "id": f"untracked-{working_dir.name}",
                "directory": str(working_dir),
                "tenant": f"tenant-{tenant}",
                "status": "active",
                "resources": {},
            }

    # Get tenant configuration
    try:
        tenant_config = get_config_for_tenant(int(tenant))
    except Exception as e:
        click.echo(f"‚ùå Error: Failed to get tenant configuration: {e}", err=True)
        sys.exit(1)

    # Initialize destroyer
    try:
        destroyer = TerraformDestroyer(working_dir, tenant_config)
    except ValueError as e:
        click.echo(f"‚ùå Error: {e}", err=True)
        sys.exit(1)

    # Check terraform is installed
    if not destroyer.check_terraform_installed():
        click.echo("‚ùå Error: Terraform is not installed or not in PATH", err=True)
        sys.exit(1)

    # Run the destruction process
    try:
        asyncio.run(
            _run_undeploy(
                destroyer=destroyer,
                deployment=deployment,
                registry=registry,
                tenant=f"tenant-{tenant}",
                force=force,
                dry_run=dry_run,
                no_backup=no_backup,
            )
        )
    except KeyboardInterrupt:
        click.echo("\n‚ö†Ô∏è  Undeployment cancelled by user", err=True)
        sys.exit(130)
    except Exception as e:
        click.echo(f"‚ùå Error: Undeployment failed: {e}", err=True)
        logger.exception("Undeployment failed")
        sys.exit(1)


async def _run_undeploy(
    destroyer: TerraformDestroyer,
    deployment: Dict[str, Any],
    registry: DeploymentRegistry,
    tenant: str,
    force: bool,
    dry_run: bool,
    no_backup: bool,
) -> None:
    """Execute the undeployment process.

    Args:
        destroyer: Terraform destroyer instance
        deployment: Deployment record
        registry: Deployment registry
        tenant: Target tenant
        force: Skip confirmations
        dry_run: Preview only
        no_backup: Skip state backup
    """
    click.echo(f"\nüöÄ Starting undeployment process for {deployment['id']}")

    # Get resources that will be destroyed
    click.echo("\nüìã Analyzing resources...")
    resources = await destroyer.get_resources_to_destroy()

    if not resources:
        click.echo("‚ö†Ô∏è  No resources found in Terraform state")
        if not force:
            if not click.confirm("Continue anyway?", default=False):
                click.echo("Undeployment cancelled")
                return

    # Run confirmation flow if not forced
    if not force and not dry_run:
        confirmation = UndeploymentConfirmation(deployment, tenant)

        if not confirmation.verify_deployment_active():
            sys.exit(1)

        confirmation.show_resources_preview(resources)

        if not confirmation.confirm_tenant():
            click.echo("‚ùå Tenant confirmation failed")
            sys.exit(1)

        if not confirmation.get_typed_confirmation():
            click.echo("‚ùå Deployment ID confirmation failed")
            sys.exit(1)

        if not confirmation.final_confirmation():
            click.echo("‚ùå Final confirmation declined")
            sys.exit(1)

    # Dry run mode - show plan only
    if dry_run:
        click.echo("\nüîç Running terraform plan -destroy (dry run)...")
        exit_code, stdout, stderr = await destroyer.plan_destroy()

        if exit_code != 0:
            click.echo(f"‚ùå Terraform plan failed:\n{stderr}", err=True)
            sys.exit(1)

        click.echo("\n--- Terraform Plan Output ---")
        click.echo(stdout)
        click.echo("\n‚úÖ Dry run complete. No resources were destroyed.")
        return

    # Backup state if not disabled
    backup_path: Optional[Path] = None
    if not no_backup and destroyer.state_file.exists():
        click.echo("\nüíæ Backing up Terraform state...")
        backup_path = registry.backup_state(deployment["id"], destroyer.state_file)
        if backup_path:
            click.echo(f"‚úÖ State backed up to: {backup_path}")
        else:
            click.echo("‚ö†Ô∏è  Failed to backup state, continuing anyway...")

    # Execute destruction
    click.echo("\nüóëÔ∏è  Executing terraform destroy...")
    click.echo("This may take several minutes...")

    exit_code, stdout, stderr = await destroyer.destroy(
        auto_approve=force or True,  # We've already confirmed
        timeout=600,  # 10 minutes
    )

    # Process results
    if exit_code == 0:
        click.echo("\n‚úÖ Resources successfully destroyed!")

        # Update registry
        if deployment["id"].startswith("deploy-"):
            registry.mark_destroyed(
                deployment["id"],
                backup_path=str(backup_path) if backup_path else None,
            )

        # Show summary
        click.echo("\nüìä Destruction Summary:")
        click.echo(f"   Deployment: {deployment['id']}")
        click.echo(f"   Directory: {deployment['directory']}")
        click.echo(f"   Resources destroyed: {len(resources)}")
        if backup_path:
            click.echo(f"   State backup: {backup_path}")
    else:
        click.echo("\n‚ùå Terraform destroy failed!", err=True)
        click.echo(f"Error output:\n{stderr}", err=True)

        # Parse remaining resources from Terraform output
        remaining_resources = _parse_remaining_resources(stderr, stdout)

        # Update registry with failure
        if deployment["id"].startswith("deploy-"):
            registry.mark_failed(
                deployment["id"],
                error=stderr[:500],  # Truncate error message
                remaining_resources=remaining_resources,
            )

        click.echo("\nüîß Recovery Options:")
        click.echo("1. Check the error message above for specific issues")
        click.echo("2. Try running with --dry-run first to preview")
        click.echo("3. Check Azure portal for resource locks or dependencies")
        click.echo(f"4. Manual cleanup may be required in: {deployment['directory']}")

        sys.exit(1)
